## **자료구조**

자료를 효율적으로 이용할 수 있도록 컴퓨터에 저장하는 방법이다*.* 신중히 선택한 자료구조는 보다 효율적인 알고리즘을 사용할 수 있게 한다. 효과적으로 설계된 자료구조는 실행시간 혹은 메모리 용량과 같은 자원을 최소한으로 사용하면서 연산을 수행하도록 해준다.

자료구조는 컴퓨터가 자료를 처리할 때, 이를 효율적으로 관리하고 구조화시키기 위해 구성하고 처리하는 작업을 의미한다.

#### **자료구조가** **필요한** **이유**

효율적으로 설계하기 위함.

여기서 효율적인 설계란 퍼포먼스의 향상과 동시에 메모리를 절약하는 방법이고, 이를 위해 자료구조의 선택이 중요함.

#### **종류**

- **선형구조** (자료들 사이의 관계가 1:1인 경우)
  - List
    - ArrayList 
    - LinkedList (단순 / 원형 / 이중)

  - Stack
  - Queue
  - Deque

- **비선형구조**(자료들 사이의 관계가 1:1이 아닌 계층구조인 경우)

  - Graph
  - Tree
    - 일반트리
    - 이진트리





## 선형구조

### List

리스트는 자료를 순서대로 저장하는 자료구조이다.

### ArrayList와 LinkedList

배열리스트는 배열을 이용해 자료를 저장하는 구조로 index number 순서대로 메모리에 저장된다. 

![array_linked_list](/Users/Dahye/Desktop/알고리즘/array_linked_list.jpg)

연결리스트는 포인터를 이용해 데이터를 저장하는 자료구조이다. 하나의 데이터를 저장하는 공간을 노드(Node)라고 부르는데 이것이 기본단위이다. 

> Node는 자료(Data)와 Link로 이루어짐

각 노드의 생성은 동적 할당으로 이루어지고 첫번째 노드를 가르치기 위한 노드로 HeaderNode 생성이 우선적으로 필요함

ArrayList는 사이즈가 고정되어 있기 때문에 삽입시 사이즈를 늘려주는 연산이 추가되어야 하고 삭제시에는 순차적인 인덱스 구조로 인해 삭제된 빈 인덱스를 채워야 하기 때문에 채워주는 연산이 추가되어야한다.

이런 부가적인 연산은 시스템의 성능저하로 이어져 삽입/삭제가 빈번하게 발생하는 프로세스의 경우에 치명적이다. 그리고 자료들이 지속적으로 삭제되는 과정에서 그 공간만큼 낭비되는 메모리가 많아지게 된다.

하지만 LinkedList는 이런 문제를 연결형태로 해결해 ArrayList에서 이루어졌던 뒤로 밀거나 채우는 작업 없이 단지 주소만 서로 연결시켜 주면 되기 때문에 추가/삭제가 빠르고 용이하다. 그래서 삽입/삭제가 빈번하게 발생하는 프로세스의 경우 LinkedList를 사용해 시스템을 구현 하는것이 바람직하다.

LinkedList의 단점으로는 ArrayList에서는 무작위 접근이 가능하지만, LinkedList에서는 순차접근만이 가능하다. 특히 단순 LinkedList는 단방향성을 갖고 있기 때문에 인덱스를 이용해 자료를 검색하는 애플리케이션에는 적합하지 않다. (사실 순차접근도 전산 이론중 하나인 참조한 데이터는 다시 참조될 가능성이 높고 참조된 데이터 주변의 데이터 역시 같이 참조될 가능성이 높다는 참조의 지역성 이론때문에 LinkedList보다는 ArrayList가 훨씬 빠르다고 함) 

n개의 자료를 저장할 때, ArrayList는 자료들을 하나의 연속적인 묶음으로 묶어 자료를 저장하는 반면 LinkedList는 자료들을 저장 공간에 불연속적인 단위로 저장한다. 그래서 LinkedList는 메모리 이곳 저곳에 산재해 저장되어 있는 노드들을 접근하는데 ArrayList 보다는 긴 지연 시간이 소모된다.

또다른 단점으로는 참조자를 위해 추가적인 메모리 할당을 해야하는 점인데 자료들의 크기가 작은 리스트의 경우 참조자를 위한 추가적인 메모리할당은 비실용적일 수 있다. 

##### LinkedList의 장단점

![linkedlist](/Users/Dahye/Desktop/알고리즘/linkedlist.jpg)

##### 성능비교

![성능비교](/Users/Dahye/Desktop/알고리즘/성능비교.jpg)

##### Hashtable

해쉬테이블은 Key에 Value를 저장하는 데이터 구조

데이터를 담을 테이블을 미리 크게 확보해 놓은 후 입력받은 데이터를 해시해 테이블 내의 주소를 계산하고 이 주소에 데이터를 담는것.

궁극의 탐색 알고리즘.

해시테이블의 성능은 공간을 팔아 시간을 얻어낸것.

https://dohkstalks.blogspot.com/2016/01/hash-table.html



### Stack & Queue & Deque



#### Stack

스택은 데이터가 들어온 순서대로 차곡 차곡 쌓이는 형태의 기억공간이다.

출력시 가장 나중에 쌓인 데이터가 제일 먼저 출력하게됨 , 선입선출, LIFO

![stack](/Users/Dahye/Desktop/알고리즘/stack.jpg)

- top : 스택 맨 위의 데이터, 최근 들어온 데이터를 가리킴

- push(item): item 하나를 스택 가장 윗 부분에 추가. top이 다음 item이 들어올 자리로 이동하면 그 자리에 item 삽입함

- pop(): 스택에서 가장 위에 있는 항목을 제거

- peek(): 스택의 가장 위에 있는 항목 반환

- isEmpty(): 스택이 비어 있을 때 true를 반환


스택이 유용한 경우는 재귀 알고리즘을 사용할 때라고 하는데, 왜..지?

> 재귀적으로 함수를 호출해야 하는 경우에 임시 데이터를 스택에 넣어주고, 재귀 함수를 빠져 나와 퇴각 검색(backrack)을 할 때는 스택에 넣어 두었던 임시 데이터를 빼 줘야한다. 스택은 이런 일련의 행위를 직관적으로 가능하게 해준다.

또, 스택은 재귀 알고리즘을 반복적형태(iterative)를 통해 구현할 수 있게 해준다. ???

 



#### Queqe

스택과 비슷하지만 선입선출, FIFO로 가장 먼저 들어온 데이터가 가장 먼저 나가게 된다.

![queue](/Users/Dahye/Desktop/알고리즘/queue.jpg)



- front: 큐에서 삭제가 일어나는 위치
- rear: 데이터가 있는 가장 끝부분, 삽입이 일어나는 곳
- add(item): item을 리스트의 끝부분에 추가
- remove(): 리스트의 첫 번째 항목을 제거
- peek(): 큐에서 가장 위에 있는 항목을 반환
- isEmpty(): 큐가 비어 있을 때에 true 반환



큐가 비어있을 경우 삭제를 하는 작업을 시도했을 때 **Queue Underflow**가 발생하게되고 큐가 꽉 차있을경우 데이터를 삽입하려 한다면 **Queue Overflow**가 발생한다.

큐는 연결리스트로 구현할 수 있고 연결리스트의 반대 방향에서 항목을 추가하거나 제거하도록 구현한다면 근본적으로 큐와 같다.



큐에서 처음과 마지막 노드를 갱신할 때 실수가 나오기 쉽다고 한다. 왜죠?

큐는 너비 우선 탐색(breadth-first-search)을 하거나 캐시를 구현하는 경우에 종종 사용된다.

예를들어, 너비 우선 탐색을 하는 경우에 처리해야 할 노드의 리스트를 저장하는 용도로 큐를 사용했다. 노드를 하나 처리할 때마다 해당 노드와 인접한 노드들을 큐에 다시 저장한다. 이렇게 함으로써 노드를 접근한 순서대로 처리할 수 있게 된다.





## 비선형구조

트리에서 탐색하는 것이 배열이나 연결리스트처럼 선형으로 구성된 자료구조에서 탐색하는 것보다 훨씬 까다롭다. 또한 최악의 수행 시간과 평균적 수행 시간이 매우 크게 바뀔 수 있어서 알고리즘을 살펴 볼 때에는 두가지 측면 모두를 반드시 따져봐야 한다. 

### 트리

- 트리는 그래프의 한부분
- 하나의 루트 노드를 갖는다(그래프 이론에서는 꼭 이래야 할 필요는 없고 보통 면접에서 사용하는 트레에선 맞는말)
- 루트 노드는 0개 이상의 자식 노드를 갖고 있다.
- 그 자식 또한 0개 이상의 자식 노드를 갖고 있고 이는 반복적으로 정의됨
- 사이클이 존재 할 수 없다. 노드들은 특정 순서로 나열될 수도 있고 그럴 수 없을수도 있다. 
- 각 노드는 어떤 자료형으로도 표현가능하다
- 각 노드는 부모 노드로의 연결이 있을 수도 있고 없을수도 있다.
- 자식이 없는 노드는 말단 노드라고 부름

##### 이진트리

각 노드가 최대 두개의 자식을 갖는 트리

##### 이진 탐색 트리

모든 노드가 아래와 같은 특정 순서를 따르는 속성이 있어야함

모든 왼쪽 자식들 <= n < 모든 오른쪽 자식들 (모두 참이어야함)

> 같은 값을 처리 하는 방식에 따라 이진 탐색 트리는 약간씩 정의가 달라질 수 있으므로 면접관에게 미리 명확히 얘기할 필요가 있다

> 또 , 트리 문제가 주어질 경우 이진 탐색 트리라고 가정해 버리는 경우가 많다. 이진 탐색 트리인지 아닌지 확실히 묻도록 하자.



##### 균형 vs 비균형

균형을 잡는다는 것이 왼쪽과 오른쪽 부분 트리의 크기가 완전히 같게 하는 것을 의미하진 않음

균형 트리인지 아닌지 확인 하는 방법 중 하나는 너무 불균형한건 아닌지 확인 하는 것 이상의 의미를 갖는다.

'균형'이란 트리의 높이 차이가 -1에서 1사이라는 뜻이다.

높이의 차가 전혀 없다는 뜻이 아님.

O(logN) 시간에 Insert와 find를 할 수 있을 정도로 균형이 잘 잡혀 있지만 완벽하게 균형 잡혀 있을 필요는 없다.

- 균형트리

  - 레드-블랙 트리
  - AVL 트리

  > 고급주제에서 다룰예정



##### 완전이진트리(complete binary tree)

트리의 모든 높에서 노드가 꽉 차 있는 이진 트리

마지막 단계(level)는 꽉 차 있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워저야 함

##### 전 이진트리(full binary tree)

모든 노드의 자식이 없거나 정확히 두개 있는 경우.

즉, 자식이 하나만 있는 노드가 존재해서는 안됨

##### 포화 이진트리(perfect binary tree)

전 이진 트리이면서 완전 이진트리인 경우.

모든 말단 노드는 같은 높이에 있어야 하며 마지막 단계에서 노드의 개수가 최대가 되어야함

- 노드의 개수 = 2^k-1^ (k=각 level의 값)


#### 이진트리 순회

##### 중위 순회(in-order-traversal)

왼쪽가지(branch), 현재노드, 오른쪽가지 순서로 노드를 방문하고 출력하는 방법 - (이진탐색트리를 이 방식으로 순회한다면 오름차순으로 방문하게됨)

##### 전위 순회(pre-order traversal)

자식 노드보다 현재 노드를 먼저 방문 (가장 먼저 방문하게 될 노드는 항상 루트)

##### 후위 순회(post-order traversal)

모든 자식 노드들을 먼저 방문한 뒤 마지막에 현재 노드를 방문



#### 이진 힙(최소힙과 최대힙)

- 최소힙 : 트리의 마지막 단계에서 오른쪽 부분을 뺀 나머지 부분이 가득 채워져 있다는 점에서 완전 이진 트리이며 각 노드의 원소가 자식들의 원소보다 작다는 특성이 있다. 따라서 루트는 트리 전체에서 가장 작은 원소가 됨
  - insert (삽입연산) - 트리의 밑바닥에서부터 삽입을 시작. 완전 트리의 속성에 위배되지 않게 새로운 원소는 밑바닥 가장 오른쪽 위치로 삽입됨. 그리고 새로운 원소가 자리를 찾을 때가지 부모 노드와 교환해 나간다.
  - extract_min (최소 원소추출 연산) - 최소 원소는 언제나 가장 위에 놓이는데, 첫번째로 최소 원소를 제거한 후에 힙에 있는 가장 마지막 원소(밑바닥 가장 왼쪽에 위치한 원소)와 교환한다. 그 다음 해당 노드를 자식 노드와 비교해 더 작은 원소와 교환해 나감으로써 밑으로 내보낸다.
- 최대힙 : 최소힙에서 원소가 내림차순으로 정렬되어 있다는 점만 다름



#### 트라이(trie: prefix tree)

n-차 트리의 변종으로 각 노드에 문자를 저장하는 자료구조

따라서 트리를 아래쪽으로 순회하면 단어 하나가 나옴

- null node : \* 노드 , 단어의 끝을 나타냄
- 각 노드는 1개에서 ALPHABET_SIZE+1개까지 자식을 갖고 있을 수 있다.





### 그래프

트리는 그래프의 한 종류라고 했는데 그렇다고 모든 그래프가 트리는 아니다. 간단하게 얘기해서 트리는 사이클이 없는 하나의 연결 그래프이다.

그래프는 단순히 노드와 그 노드를 연결하는 간선(edge)을 하나로 모아 놓은 것과 같다.

- 방향성있는 간선 - 일방통행 / 방향성없는 간선 - 양방향 통행
- 순환 / 비순환(사이클없음) 그래프



##### 인접리스트

그래프를 표현할 때 사용되는 가장 일반적인 방법

모든 정점(노드)을 인접 리스트에 저장한다. 무방향 그래프에서 (a, b)간선은 두번 저장된다. 

##### 인접행렬

N X N boolean matrix로써 matrix\[i][j]가 true라면 i에서 j로의 edge가 있다는 뜻.

- 무방향 그래프를 인접 행렬로 표현한다면 이 행렬은 대칭행렬이 됨


##### 그래프 탐색

- **DFS** - 깊이우선탐색(**depth-first search**)

  루트 노드에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법. 넓게 탐색하기 전에 깊게 탐색

  > 모든 노드를 방문하고자 할 때 더 선호
  >
  >  ex. A노드를 방문한 뒤 A와 인접한 노드들을 차례로 순회한다. A와 이웃한 노드 B를 방문했다면 A와 인접한 또 다른 노드를 방문하기 전에 B의 이웃 노드들을 전부 방문해야 한다.  B의 분기를 전부 완벽하게 탐색한 뒤에야 A의 다른 이웃 노드를 방문 할 수 있다.
  >
  > 전위 순회를 포함한 다른 형태의 트리 순회가 모두 DFS의 한 종류.
  >
  > **구현**할 때, 그래프의 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사해야한다. 이를 검사하지 않을 경우 무한루프에 빠질 위험이 존재함

  ```java
  //pseudocode
  void search(Node root) {
      if (root == null) return;
      visit(root);
      root.visited = true;
      for each (Node n in root.adjacent) {
          if (n.visited == false) {
              search(n);
          }
      }
  }
  ```

- **BFS** - 너비우선탐색(**breadth-first search**)

  루트 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법. 깊게 탐색하기 전에 넓게 탐색(함께아는친구)

  > 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 더 선호
  >
  > 재귀적으로 동작하지 않고 큐(queue)를 사용한다
  >
  > 일반적으로 큐를 이용해 반복적 형태로 구현하는 것이 가장 잘 동작한다.
  >
  > ex. A노드에서 시작한다고 했을 때, A 노드의 이웃 노드를 모두 방문한 다음에 이웃의 이웃들을 방문한다. A에서 시작해서 거리에 따라 단계별로 탐색한다.

  ```java
  void search(Node root) {
      Queue queue = new Queue();
      root.marked = true;
      
      queue.enqueue(root); //큐 끝에 추가한다
      
      while (!queue.isEmpty()) {
          Node r = queue.dequeue(); //큐의 앞에서 뽑아낸다.
          visit(r);
          foreach (Node n in r.adjacent) {
              if (n.marked == false) {
                  n.marked = true;
                  queue.enqueue(n);
              }
          }
      }
  }
  ```

- **양방향 탐색**(**bidirectional search**)

  출발지와 도착지 사이에 최단 경로를 찾을 때 사용된다.

  기본적으로 출발지와 도착지 두 노드에서 동시에 너비 우선 탐색을 수행한 뒤, 두 탐색 지점이 충돌하는 경우에 경로를 찾는 방식

  > 너비 우선 탐색보다 더 빠르다.







## 정렬과 탐색



### 정렬

#### 버블정렬(buble sort)

- **평균 및 최악 실행시간: O(n^2^), 메모리: O(1)**

  배열의 첫 원소부터 순차적으로 진행. 

  현재 원소가 다음 원소의 값보다 크면 두 원소를 바꾸는 작업을 반복.

#### 선택정렬(selection sort)

- **평균 및 최악 실행시간: O(n^2^), 메모리: O(1)**

  비효율적이지만 배열을 선형 탐색하며 가장 작은 원소를 배열 맨 앞으로 보낸다. 그 다음 두번쨰로 작은 원소를 찾은 뒤 앞으로 보내준다.

#### 병합정렬(merge sort)

- **평균 및 최악 실행시간: O(nlogn), 메모리: 상황에따라 다름**

  배열을 절반씩 나누어 각각 정렬한 다음 이 둘을 합해 다시 정렬하는 방법.

  나눈 절반을 정렬할 때도 같은 알고리즘이 사용되고 결국에는 원소 한개 짜리 배열 두개를 병합하게 된다.

#### 퀵정렬(quick sort)

- **평균 O(nlogn), 최악 O(n^2^), 메모리: O(logn)**

  무작위로 선정된 한 원소를 사용해 배열을 분할하는데, 선정된 원소보다 작은 원소들은 앞에, 큰 원소들은 뒤로 보낸다. 배열 분할 작업은 연속된 스왑 (swap) 연산을 통해 효율적으로 수행된다.

  > 배열 분할에 사용되는 원소가 중간값, 적어도 중간값에 가까운 값이 되리라는 보장이 없기 때문에, 정렬 알고리즘이 느리게 동작할 수도 있다.

#### 기수정렬(radix sort)

- **실행시간: O(kn)**

  데이터가 정수처럼 유한한 비트로 구성되어 있는 경우 사용. 

  각 자릿수를 순회해 나가면서 각 자리의 값에 따라 그룹을 나눈다. 정수 배열이 주어졌다고 하면 처음에는 첫 번째 자릿수를 기준으로 정렬한다. 따라서 첫 자릿수가 0인 수들은 같은 그룹에 속한다 그런다음 각 그룹마다 두번 째 자리숫를 기준으로 다시 정렬을 수행한다. 

  > 비교 연산을 사용하는 정렬 알고리즘은 평균적으로  O(nlogn)보다 나은 성능을 보일 수 없으나 기수정렬의 수행시간은 O(kn)이 된다.( n=정렬대상원소의 개수, k=자릿수의개수 )



### 탐색

이진탐색









## 개념과 알고리즘

#### 비트조작

^ (XOR) , ~ (NOT)

- shift  - 왼쪽 또는 오른쪽으로 1 bit씩 이동시키는 연산
- Rotate - shift에서 밀려 나가는 비트의 값을 반대편에 입력하는 작업을 하는 연산

**컴퓨터는 정수를 저장할 때 2의 보수 형태로 저장**

http://ndb796.tistory.com/4

양수를 표현할 땐 아무문제 없지만 음수를 표현할 땐 그수의 절댓값에 부호비트(sign bit)를 1로 세팅한 뒤 2의 보수를 취한 형태로 표현

N 비트 숫자에 대한 2의 보수는 2^N^ 에 대한 보수값과 같다. (N = 부호비트를 뺀 나머지 값을 표현할 때 사용되는 비트의 개수)

##### 산술 우측 시프트 vs 논리 우측 시프트

산술우측시프트는 비트를 오른쪽으로 옮긴 후 부호비트는 바꾸지 않는다. 이 연산은 대략 2로 나눈 효과가 있고 >> 연산과 같다

논리우측시프트는 비트를 오른쪽으로 옮긴다음 최상위비트인 부호비트에 0을 넣는다. 이 연산은 >>>연산과 같다. 

padding bit = 사용하지 않는 비트



> 참고: http://onboardfly.tistory.com/29
>
> AND - 둘다 1일경우만 1출력이니, 삭제할 부분의 bit를 AND시키면 해당 bit가 삭제되는데 이 때 삭제하기 위해 대응시킨 0을 Masking Bit라고 한다.
>
> OR - 특정 문자나 bit를 삽입시킬 때 사용한다. 특정 Bit에 1을 세트하기 위해 해당 Bit의 위치에 삽입할 문자나 1을 OR연산한다.
>
> XOR - exclusive or 로 한비트라도 다르면 1을 출력하는 연산을 수행하므로 2개의 데이터를 비교하거나 반전시키는 작업을 하고싶을 때 사용한다.
>
> NOT - 보수. 반대되는 비트를 출력



#### 수학 및 논리퍼즐

##### 소수

모든 자연수는 소수의 곱으로 나타낼 수 있다.

##### 가분성(divisibility)

##### 소수판별

어떤수 n이 소수인지 여부를 판별하는 가장 단순한 방법은 2에ㅓ n-1까지 루프를 돌면서 나누어지는 경우가 있는지 확인해보는 것이다.

##### 에라토스테네스의 체 

소수 목록 만들기

##### 확률

P(A∩B) = P(B|A)P(A)=P(A|B)P(B)이므로

P(A|B) = P(B|A) P(A)/P(B)인데, 이 수식을 **베이즈 정리**라고 부른다.

##### 독립사건과 상호베타적사건

독립성 = P(A∩B) = P(A)P(B) = 한사건의 발생과 다른 사건의 발생 사이에 아무런 관계가 없는 경우

상호베타 = P(A∪B) = P(A) + P(B) = 한사건이 일어나면 다른 한사건은 일어날수 없는경우



> 두개의 끈이 주어졌을 때 15분을 재는 방법은?
>
> 하나의 끈을 모두 태우는데는 1시간이 소요됨

최악의 경우 균형을 가져다 주는 방법



#### 재귀와 동적 프로그래밍

주어진 문제가 재귀인지 확인해 보는 좋은 방법은 해당 문제를 작은 크기의 문제로 만들수 있는지 보는 것이다.

다음같은 문장으로 시작되는 문제는 재귀로 풀기 적당한 문제일 가능성이 높다(항상그런것은 아님)

- n번째 ~를 계산하는 알고리즘을 설계해라
- 첫 n개를 나열하는 코드를 작성하라 
- 모든 ~를 계산하는 메서드를 구현하라 등



##### 상향식접근법 하향식접근법 반반접근법

##### 재귀적해법 vs 순환적해법

재귀적 알고리즘을 사용하면 공간 효율성이 나빠질 수 있다. 재귀 호출이 한번 발생할 때마다 스택에 새로운 층을 추가해야한다. 이는 재귀의 깊이가 n일때 O(n)만큼의 메모리를 사용하게 된다는것을 의미한다.

이런 이유로 재귀적 알고리즘은 순환적으로 구현하는 것이 더 나을수 있다. 모든 재귀적 알고리즘은 순환적으로 구현될 수 있지만 순환적으로 구현된 코드는 때로 훨씬 더 복잡하다. 재귀적으로 코드를 작성하기 전에 순환적으로 작성하면 얼마나 더 어려울지 자문해보고 두방법 사이의 타협점에 대해서 면접관과 상의해 봐야한다.



##### 동적계획법 & 메모이제이션

동적프로그래밍은 거의 대부분 재귀적 알고리즘과 반복적으로 호출되는 부문문제를 찾아내는 것이 관건이다.

이를 찬은 뒤에는 나중을 위해 현재 결광=를 캐시에 저장해 놓으면 된다.

혹은 재귀 호출의 패턴을 유심히 살펴본 뒤에 이를 순환적 형태로 구현할 수도 있다. 물론 여전히 결과를 캐시에 저장해야 한다.

동적 프로그래밍을 설명하는 가장 간단한 예시는 

n번째 피보나치 수를 찾는것이다.

이런 문제를 풀때는 일반적인 재귀로 구현한 뒤 캐시 부분을 나중에 추가하는 것이 좋다.

```c
int fibonacci(int i) {
    if(i==0) return 0;
    if(i==1) return 1;
    return fibonacci(i-1) + fibonacci(i-2);
}
```

O(n^2^)





## 테스팅

관련 면접 문제

```
1. 실생활에서 접하는 객체를 테스트해라
2. 소프트웨어 하나를 테스트해라.
3. 주어진 함수에 대한 테스트 코드를 작성해라
4. 발생한 이슈에 대하 해결책을 찾아내라.
```

### 실제 세계에서 객체 테스트하기

- 사용자가 누군지 정하기 / 사용목적 생각하기

  문제를 풀기전에 해당 제품을 어떤 사용자가 어떤 목적으로 사용하게 될지 면접관과 의논해야함

- 어떤 use case가 있는지 

- 한계조건
- 스트레스 조건과 장애조건
- 테스트는 어떻게 수행할지

#### 

### 소프트웨어 테스팅

- 수작업 vs 자동화

- 블랙박스 vs 화이트박스

  - 블랙박스 테스트 - 소프트웨어를 주어진 그대로 테스트

  - 화이트박스 테스트 - 그 내부의 개별 함수들을 프로그램적으로 접근하여 테스트


### 함수 테스트

함수 입출력을 확인하는 테스트만 하면 된다

- 1단계: 테스트 케이스정의
  - 정상적인 케이스
  - 극단적인 케이스
  - null 입력, 잘못된 입력
  - 특수한 입력

- 2단계: 예상되는 결과를 정의
- 3단계: 테스트 코드 작성



### 문제 해결에 관한 문제

이미있는 장애를 어떻게 디버깅하고 해결할 것인가?

1. 시나리오를 이해해라

2. 문제를 쪼개라 

   상황이 전개되는 순서대로 테스트 가능한 단위로 분할한다

3. 구체적이로 관리 가능한 테스트들을 생성

## 







## 객체지향 설계



#### 접근법

1. 모호성을 해소해라

   누가 그것을 사용할것이며 사용 목적이 어떤지에 대한 질문을 꼭 해야한다. (육아원칙에 따라서)

2. 핵심 객체의 설계

   예를들어 식당을 객체지향적으로 설계한다고 해보면 핵심 객체로는 테이블/손님/인원수/주문/직원수/등등이 있을수 있음

3. 관계분석

   객체 사이의 관계를 분석해야함.

   - 어떤 객체가 어떤 객체에 속해 있는가? 
   - 다른 객체로부터 상속받아야 하는 객체는 있나? 
   - 관계는 다대다 관계인가 아니면 일대일 관계인가?

4. 행동분석

   핵심행동들에 대해서 생각하고 이들이 어떻게 상호작용해야 하는지 따져봐야함



#### 디자인 패턴

아래 두가지만 일단 알아두자.

- singletone

  - 어떤 클래스가 오직 하나의 객체만을 갖도록 함

  - 프로그램 전반에 걸쳐 그 객체 하나만 사용되도록 보장해야함

  - 정확히 하나만 생성되어야 하는 전역 객체를 구현해야 하는 경우 특히유용함

  - 단위테스트(unit test)에 방해되는 요인이긴함

    > 왜??

- factory method
  - 어떤 클래스의 객체를 생성하기 위한 인터페이스를 제공하되 하위 클래스에서 어떤 클래스를 생성할지 결정할 수 있도록 도와줌

  > 모르겠다.







## 시스템 설계 및 규모 확장성



#### 시스템설계 : 단계별 접근법

1. 문제의 범위를 한정해라

   정확히 무엇을 구현해야 하는지 알아야 함

2. 합리적인 가정을 만들자

3. 중요한 부분을 먼저 그려라

   시스템의 주요한 부분을 다이어그램으로 그려라

   시스템의 처음부터 마지막까지 어떻게 동작하는기 그 흐름을 보여줘라.

4. 핵심 문제점을 찾아라

   어떤부분의 병목지점일까 이 시스템이 풀어야할 주된 문제는?

5. 핵심 문제점을 해결할 수 있도록 다시 설계해라



#### 규모 확장을 위한 알고리즘: 단계별 접근법

1. 질문해라 

2. 현실적 제약을 무시해라 

   메모리 제약없고 컴퓨터 한대에서 모든 데이터를 다 처리할 수 있다록 가정해도된다.

3. 현실로 돌아와라 

   컴퓨터 한대에 저장할 수 있는 데이터의 크기는 얼마나되고 데이터를 뎌러 조각으로 쪼갰을 때 어떤 문제가 발생할지 생각해 봐라

4. 문제를 풀어라

   새로운 문제점을 만들어 내서 그 문제를 분석하고 풀 수 있는 능력을 입증하면 됨



#### 시스템 설계의 핵심 개념

시스템은 두가지 방법으로 규모를 확장시킬 수 있다

##### 수직적 규모 확장(vertical scaling)

특정 노드의 자원의 양을 늘리는 방법, 예로 서버에 메모리를 추가해 서버의 처리 능력을 향상 시키는것

> 수평적 규모 확장보다 수직적 규모 확장이 쉽지만 메모리 혹은 디스크와 같은 것만 추가할 수 있으므로 제한적이다. 

##### 수평적 규모 확장(load balancer)

노드의 개수를 늘리는 방법, 예로 서버를 추가함으로써 서버 한대가 다뤄야 하는 부하(load)를 줄일수 있다.



##### 서버 부하 분산 장치(load balancer)

규모 확장성이 있는 웹사이트의 프론트엔드 부분은 서버 부하 분산 장치(load balancer)를 통해서 제공된다.

이렇게 해야 서버에 걸리는 부하를 여러 대의 서버에 균일하게 분산시킬 수 있고 서버 한대 때문에 전체 시스템이 죽거나 다운되는 상황을 방지할 수 있다.





##### 데이터베이스 역정규화(denormalization)와 NoSQL

조인연산은 시스템이 커질수록 굉장히 느려진다. 그래서 조인 연산은 가능하면 피해야 함

역정규화가 이런 것들중 하나임

- 역정규화란?

데이터베이스에 여분의 정보를 추가해서 읽기 연산 속도를 향상시킨것

- NoSQL

조인연산 자체를 아예 지원하지 않으므로 자료를 저장할 때 조금 다른 방식으로 구성해 놓는데 이 방식이 규모 확장성에 좋도록 설계되어 있다



### 데이터베이스 분할(샤딩)

샤딩은 데이터를 여러 컴퓨터에 나눠서 저장하는 동시에 어떤 데이터가 어떤 컴퓨터에 저정되어 있는지 알수 있는 방식

- 수직적 분할(vertical partitioning) : 기본적으로 자료의 특성 별로 분할하는 방식

  예를들어, 개인 정보와 관련된 부분 혹은 메시지와 관련된 부분과 같이 그 특성에 따라 자료를 분할 할 수 있다.

- 키 혹은 해시 기반 분할 : mod(key,n)의 값을 이용해 N개의 서버에 분할 저장하면 간단하게 구현가능. 

- 디렉터리 기반 분할 : 데이터를 찾을 때 사용되는 조회 테이블을 유지하는 방법. 이 방법이 상대적으로 추가하기 쉽지만, 두가지 단점이 있음 (1. 조회 테이블이 단일 장애지점이 될 수 있고 2. 지속적으로 테이블을 읽는 행위가 전체성능에 영향미칠수 있다)

##### 캐싱(caching)

인메모리 캐시를 사용하면 결과를 굉장히 빠르게 가져올 수 있다.

인 메모리 캐시는 키-값(key-value)을 쌍으로 갖는 간단한 구조로써 일반적으로 애플리케이션과 데이터 저장소사이에 자리잡고 있음

##### 비동기식처리 & 큐

이상적이라면, 속도가 느린 연산은 비동기식으로 처리해야 한다.

##### 네트워크 성능 척도

- 대역폭(bandwidth) : 단위 시간에 전송할 수 잇는 데이터의 최대치

  보통 초당 몇 비트를 봰ㄹ수 있는지로 계산. 

- 처리량(throughput) : 단위 시간에 실제로 전송된 데이터의 양

- 지연속도(latency) : 데이터를 전송하는데 걸리는 시간

  발송자가 데이터를 보낸 시점부터 수신자가 데이터를 받는 시점까지 걸린시간



##### MapReduce

큰 데이터를 처리하는데 사용되는데 병렬로 처리할 수 있게 도와주기 때문에 규모 확장이 쉽다. 맵 단계와 리듀스 단계를 구현해야한다. 나머지부분은 시스템이 알아서 처리할것임

- Map은 데이터를 입력으로 받은 뒤 <key, value>쌍으로 반환한다.

- Reduce는 키(key), 그리고 키와 관련된 값(value)들을 입력으로 받은 뒤 처리과정을 거친뒤 새로운 키와 값을 반환한다.


#### 시스템 설계 시 고려할 점

- 실패 - 대비책을 준비해야함
- 가용성 및 신뢰성
- 읽기 vs 쓰기 중심
- 보안



#### 완벽한 시스템은 없다!!